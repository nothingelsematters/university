# Haskell: ДЗ 3 -- Строгость. Многопоточность. Продвинутые типы. Линзы. Комонады.

## [Задание 1. Геометрия](src/Geometry.hs)
В данном задании от вас требуется создать дататайп `Point`, который будет представлять точку в двумерном пространстве с целочисленными координатами.

Затем реализуйте функции для работы с точками:
```haskell
plus          :: Point -> Point -> Point
minus         :: Point -> Point -> Point
scalarProduct :: Point -> Point -> Int
crossProduct  :: Point -> Point -> Int
```

Затем реализуйте функции, которые принимают на вход многоугольник без самопересечений, заданный координатами его вершин в порядке против часовой стрелки. Многоугольник может быть как выпуклый, так и не выпуклый.
```haskell
perimeter  :: [Point] -> Double -- Считает периметр
doubleArea :: [Point] -> Int    -- Считает удвоенную площадь
```
Функции должны обрабатывать многоугольники с количеством точек до $10^7$ за 1-2 секунды.

Чтобы ускорить реализацию, делайте Ваш код строгим по возможности и используйте примитивы многопоточности.

#### [Усложненное задание](bench/GeometryBench.hs)
Необходимо написать несколько тестов измеряющих перфоманс, используя пакет `criterion`.
Напишите для тестов более наивную реализацию и сравните их по времени и памяти.

## [Задание 2. Хэш таблица](src/ConcurrentHashTable.hs)
В данном задании от Вас требуется написать хэш таблицу, которая способна обрабатывать запросы из нескольких потоков одновременно. Хэш таблица должна работать довольно быстро для $10^5$ параллельных запросов.

Необходимо реализовать следующий дататайп:
```haskell
data ConcurrentHashTable k v = ...your code here..
```
а затем следующие функции:

```haskell
newCHT  :: IO (ConcurrentHashTable k v)
getCHT  :: k -> ConcurrentHashTable k v -> IO (Maybe v)
putCHT  :: k -> v -> ConcurrentHashTable k v -> IO ()
sizeCHT :: ConcurrentHashTable k v -> IO Int
```
Сигнатуры функций даны без констреинтов, потому что они будут зависеть от реализации.

Ваша реализация должна удовлетворять следующим условиям:
* выполнять все операции `put` в конечном итоге, если все потоки завершаются
* быть устойчива к асинхронным исключениям: асинхронное исключение не должно делать состояние хэш-таблицы неконсистентным
* использовать $O(n)$ памяти, где $n$ - количество добавленных элементов

Для реализации можете использовать примитивы для конкаренси, такие как `MVar`, `TVar`, `TMVar` и другие.

#### [Усложненное задание](bench/ConcurrentHashTableBench.hs)
Необходимо написать несколько тестов измеряющих перфоманс, используя пакет `criterion`. Также необходимо написать несколько тестов, проверяющих корректность операций и устойчивость к асинхронным исключениям.

## [Задание 3. HalyavaScript](src/Script.hs)

В данном задании от Вас потребуется реализовать новый язык программирования, который назовём HalyavaScript.

HalyavaScript -- статически типизируемый язык программирования, повторяющий основные конструкции языка JavaScript.
Реализовать HalyavaScript требуется в виде eDSL на Haskell, таким
образом получая type inference и parsing из коробки.
Ваша реализация HalyavaScript должна поддерживать как минимум конструкции `if` и `while`.

Ваш DSL HalyavaScript должен поддерживать любые три типа из следующих (разрешается поддерживать больше типов):

 * `Int32` (конвертируется в `Number`)
 * `Double` (конвертируется в `Number`)
 * `String`
 * `Boolean`
 * Функции от одного и двух агрументов

Конкретный синтаксис Вам предлагается разработать самим.
Для вдохновения можно использовать пример ниже:

```haskell
-- | For a given @x@ calculates @ceiling (log2 (a))@
log2 =
  sFun1 $ \a logCnt ->
  sWithVar 0 $ \accum ->
    accum @= 1 #
    logCnt @= 0 #
    sWhile (a @> eRead accum)
      ( accum @= eRead accum + eRead accum #
        logCnt @= eRead logCnt + 1
      )
```
Обратите внимание, что у данной функции специально отсутвует сигнатура типа, чтобы Вы имели возможность придумать все типы сами.

Для реализации можете использовать GADT, tagless final, Free монады и другие продвинутые подходы языка.

Реализуйте интерпретатор Вашего языка, который будет интерпретировать код написанный на HalyavaScript.

К реализации должен быть приложен [простой пример программы](test/ScriptSpec.hs), в котором задействованы три разных типа.

## [Задание 4. HalyavaScript to JavaScript](src/ScriptPrinter.hs)

Реализуйте еще один интерпретатор, который будет конвертировать код на HalyavaScript в строковое представление.

Например, код из предыдущего задания должен выглядеть как-то так. Необязательно точь-в-точь так же.

```javascript
function(v0){
  var v1=0;
  var v2=0;
  v2=1;
  v1=0;
  while ((v0) > (v2)) {
    v2=(v2) + (v2);
    v1=(v1) + (1);
  }
  return v1
}
```

Напишите несколько unit-тестов, которые конвертируют код в строку и сравнивают ее с ожидаемым результатом.

## Линзы

### [Задание 5: FileSystem lenses](src/FileSystemLens.hs)

Разрешается использовать пакет `microlens`.

Задан тип данных, которым можно представить простое дерево файловой системы:
(record-syntax в суммах типов это все еще плохо)

```haskell
data FS
    = Dir
    { name     :: FilePath  -- название папки, не полный путь
    , contents :: [FS]
    }
    | File
    { name     :: FilePath  -- название файла, не полный путь
    }
```
Создайте функцию, которая «сканирует» заданную директорию и создаёт объект типа `FS` наподобие функции [`getDirectory'`](https://hackage.haskell.org/package/filesystem-trees-0.1.0.6/docs/System-File-Tree.html#v:getDirectory-39-).

После этого создайте базовые линзы и призмы Вашего типа данных.

### Практика на линзы

> Блок практики не оценивается баллами. Он лишь предоставляет набор команд, которые полезно научиться реализовывать в одну строку при помощи линз, прежде чем приступать к дальнейшим заданиям. Все команды в списке очень простые, но если Вы не можете выполнить и их, значит, Вы не до конца разобрались с линзами, и выполнять дальнейшие задания ещё рано.

1. Список поддеревьев папки для `Dir`, иначе пустой список.
2. `Maybe` с именем директории, если `Dir`, или `Nothing` иначе.
3. Имя файла, если `File`, или пустую строку иначе.
4. Изменить имя корня дерева на `/`.
5. Добавить произвольный суффикс к имени корня дерева.
6. Получить имя самой первой папки в списке поддиректорий (`Nothing`, если такой нет).
7. Получить список имён только `File` из `Dir` (нерекурсивно).

### [Задание 6: Обходы FS](src/FileSystemTraversal.hs)

Реализуйте следующие `Lens` или `Traversal`:

1. `cd`: перейти в поддиректорию с указанным именем.
2. `ls`: получить список имён содержимого директории.
3. `file`: получить имя конкретного `File`, если он существует.

В итоге должна быть возможность делать нечто похожее:

```haskell
myDir ^?  cd "A" . cd "B" . file "C"  -- Just "C" при существовании myDir/A/B/C
myDir ^.. cd "A" . cd "B" . ls        -- получить содержимое myDir/A/B/
```

### [Задание 7: Изменения структуры FS](src/FileSystemChange.hs)

#### Базовая версия

Реализуйте следующие функции, используя линзы:

1. Изменить в директории расширения всех файлов на другое (нерекурсивно).
2. Получить имена всех файлов и директорий рекурсивно.
3. Удалить выбранную поддиректорию, только если она пустая.

#### Усложнённое задание

4. Получить полный путь к файлу с названием файла относительно стартового узла `FS`.

Интерфейс должен быть следующим:

```haskell
ghci> myDir ^? move "A" . move "B" . getPath  -- myDir is labeled by 'root'
Just "root/A/B/"
```

Разумеется, что все действия происходят над Вашей структурой данных, а в вашей файловой системе ничего не меняется.

## [Задание 8: Comonad-19](src/Comonad19.hs)

Задача: реализовать симуляцию распространения Covid-19 на двумерной сетке.

Нужно реализовать модель "Вероятность заражения" из https://kapter.github.io/outbreak с дополнением в виде учета повторно заболевших.

Задаются параметры:
* Вероятность заражения (0 < p < 1) -- оценка отношения приведших к заражению числа контактов к общему числу контактов между конкретно взятым инфицированным и его соседями
* Инкубационный период (дни)
* Болезнь с симптомами (дни)
* Длительность иммунитета (дни) -- сколько дней человек не может повторно заразиться после выздоровления


(Человек, у которого болезнь протекает в инкубационном периоде либо с активными симптомами, способен передать инфекцию незараженному соседу с вероятностью p)
Используйте тип Grid из лекции:
```haskell
newtype Grid a = Grid { unGrid :: ListZipper (ListZipper ad) }
```
Реализуйте функции для:
* получения двумерной сетки с одним зараженным посередине
* выполнения одного шага симуляции
* распечатывания всей сетки: # для активно зараженного, @ для выздоровевшего с активным иммунитетом и пустое место для здорового без иммунитета

P.S. для простоты инициализируйте все ячейки объектом типа StdGen и используйте  его в качестве случайного генератора всякий раз, когда возникнет необходимость сгенерировать случайное число в клетке (когда клетка находится в инкубационном периоде либо активной стадии болезни).
